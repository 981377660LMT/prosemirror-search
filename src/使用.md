好的，这个问题非常好。你已经深入了解了 prosemirror-search 的内部实现，现在我们把视角切换到“使用者”的角度，看看一个开发者如何在自己的项目中集成和使用这个功能。

prosemirror-search 的设计遵循了 ProseMirror 的最佳实践，即**将内部状态管理与外部交互清晰地分离开**。外部使用者通过一组明确的 API（插件、命令、状态函数）来与其交互。

下面是一个完整的分步指南，讲解如何从零开始使用它。

---

### 场景：构建一个带查找/替换功能的编辑器

假设我们有一个基本的 ProseMirror 编辑器实例 (`view`)，现在想为它添加一个搜索框、几个“上一个/下一个”和“替换”按钮。

#### 第 1 步：集成插件 (基础)

首先，你必须将 `search` 插件添加到编辑器的状态中。这是所有功能得以运行的前提。

```typescript
// 在你的编辑器设置文件中
import { EditorState } from 'prosemirror-state'
import { EditorView } from 'prosemirror-view'
import { schema } from 'prosemirror-schema-basic'
import { exampleSetup } from 'prosemirror-example-setup'

// 1. 导入 search 插件
import { search } from 'prosemirror-search'

const state = EditorState.create({
  schema,
  plugins: [
    // 2. 将 search() 插件实例添加到插件数组中
    search(),
    ...exampleSetup({ schema })
  ]
})

const view = new EditorView(document.querySelector('#editor'), {
  state
  // ...
})

// 从现在起，你的编辑器就拥有了管理搜索状态的能力，只是我们还没告诉它要搜什么。
```

---

### 第 2 步：发起或更新一个搜索 (核心交互)

当用户在搜索框中输入文字时，你需要通知 prosemirror-search 插件更新它的查询状态。

**黄金法则**: 你永远不能直接修改插件的状态。你必须通过**派发一个事务 (Transaction)**，并使用 `setSearchState` 函数将你的意图作为元数据 (meta) 附加到这个事务上。

```typescript
// 假设你有一个搜索输入框
const searchInput = document.getElementById('search-input') as HTMLInputElement
const caseSensitiveCheckbox = document.getElementById('case-sensitive') as HTMLInputElement

// 1. 导入需要用到的 API
import { SearchQuery, setSearchState } from 'prosemirror-search'

function startOrUpdateSearch() {
  const queryText = searchInput.value
  if (!queryText) {
    // 如果输入为空，可以发起一个空的查询来清除高亮
    // ...
    return
  }

  // 2. 创建一个 SearchQuery 实例
  // 这是描述“搜什么”和“怎么搜”的数据对象
  const query = new SearchQuery({
    search: queryText,
    caseSensitive: caseSensitiveCheckbox.checked
    // ... 其他选项，如 regexp, wholeWord 等
  })

  // 3. 创建一个事务，并用 setSearchState 附加元数据
  // 这是与插件通信的唯一正确方式！
  const tr = view.state.tr
  setSearchState(tr, query)

  // 4. 派发这个事务
  view.dispatch(tr)
}

// 5. 将这个函数绑定到你的 UI 事件上
searchInput.addEventListener('input', startOrUpdateSearch)
caseSensitiveCheckbox.addEventListener('change', startOrUpdateSearch)
```

**发生了什么？**

1.  `setSearchState` 将你的 `query` 对象打包成元数据，放进事务里。
2.  `view.dispatch(tr)` 将事务发送给 ProseMirror。
3.  ProseMirror 将事务传递给所有插件的 `apply` 方法，包括 `search` 插件。
4.  `search` 插件的 `apply` 方法检测到你附加的元数据，用它创建一个新的 `SearchState`，并调用 `buildMatchDeco` 重新计算所有匹配项的高亮。
5.  新的 `DecorationSet` 通过 `props` 应用到视图上，用户就能看到高亮了。

---

### 第 3 步：执行查找和替换操作 (命令)

当用户点击“下一个”、“上一个”、“替换”等按钮时，你需要执行相应的命令。prosemirror-search 已经为你导出了这些预设好的命令。

```typescript
// 假设你有一组按钮
const findNextButton = document.getElementById('find-next')
const findPrevButton = document.getElementById('find-prev')
const replaceButton = document.getElementById('replace')
const replaceAllButton = document.getElementById('replace-all')

// 1. 导入预设的命令
import { findNext, findPrev, replaceNext, replaceAll } from 'prosemirror-search'

// 2. 在按钮的点击事件中执行命令
// ProseMirror 命令的标准执行方式是：command(state, dispatch)
findNextButton.addEventListener('click', () => {
  // findNext 是一个命令函数
  findNext(view.state, view.dispatch)
  view.focus() // 执行后让编辑器重新获得焦点
})

findPrevButton.addEventListener('click', () => {
  findPrev(view.state, view.dispatch)
  view.focus()
})

replaceButton.addEventListener('click', () => {
  // 在执行替换前，需要确保 SearchQuery 中包含了 replace 文本
  // (这通常在 startOrUpdateSearch 中完成)
  replaceNext(view.state, view.dispatch)
  view.focus()
})

replaceAllButton.addEventListener('click', () => {
  replaceAll(view.state, view.dispatch)
  view.focus()
})
```

**发生了什么？**

- 当你调用 `findNext(view.state, view.dispatch)` 时，`findNext` 命令会从当前状态中获取 `SearchState`，找到下一个匹配项，然后创建一个包含**选区移动**的新事务并派发它。编辑器视图随之更新，光标跳转到下一个匹配项。
- `replaceNext` 的逻辑更复杂，它会创建一个包含**文本替换**和**选区移动**的事务。

---

### 第 4 步：读取状态以更新 UI (可选，但推荐)

有时你的 UI 需要知道当前的状态，比如显示“找到 3 / 10 个匹配”。你可以通过 `getSearchState` 和 `getMatchHighlights` 来获取这些信息。

```typescript
// 1. 导入状态获取函数
import { getSearchState, getMatchHighlights } from 'prosemirror-search'

// 你可以在每次视图更新时检查状态
const view = new EditorView(document.querySelector('#editor'), {
  state,
  dispatchTransaction(transaction) {
    // 这是监听编辑器状态变化的好地方
    const newState = view.state.apply(transaction)
    view.updateState(newState)

    // 更新我们的 UI
    updateSearchUI(newState)
  }
})

function updateSearchUI(state: EditorState) {
  const searchState = getSearchState(state)
  const matchCount = getMatchHighlights(state).size // DecorationSet 的 size 就是匹配数

  const infoDisplay = document.getElementById('search-info')

  if (searchState && searchState.query.valid) {
    infoDisplay.textContent = `找到 ${matchCount} 个匹配项。`
  } else {
    infoDisplay.textContent = ''
  }
}
```

### 总结：外部使用的核心 API

与 prosemirror-search 交互，你只需要关心以下几个导出的成员：

1.  **`search()` (Plugin)**: 用于**安装**功能。
2.  **`SearchQuery` (Class)**: 用于**描述**你要搜什么。
3.  **`setSearchState(tr, query)` (Function)**: 用于**发起或更新**一个搜索请求。这是**写操作**的唯一入口。
4.  **`findNext`, `replaceNext`, etc. (Commands)**: 用于执行**用户操作**，如跳转和替换。
5.  **`getSearchState(state)` (Function)**: 用于**读取**当前搜索的配置。这是**读操作**的入口。
6.  **`getMatchHighlights(state)` (Function)**: 用于**读取**搜索的结果（高亮数量）。

通过这套清晰的 API，prosemirror-search 将复杂的内部逻辑与外部的 UI 控制完全分离开，使得集成工作变得非常简单和可预测。
